#!/usr/bin/env python3
"""
M√≥dulo de integraci√≥n con Conagua/SMN para datos meteorol√≥gicos reales
Author: EdbETO Solutions Team
Repositorio: https://github.com/Edbeto13/Hydredelback
Licencia: MIT
"""

import json
import os
import time
import threading
import requests
from datetime import datetime, timedelta
from urllib.parse import urlencode
from typing import Dict, List, Optional, Any

class ConaguaDataCollector:
    """Recolector autom√°tico de datos meteorol√≥gicos de Conagua/SMN"""
    
    def __init__(self, cache_file: str = 'weather_cache.json', update_interval: int = 4500):  # 75 minutos = 4500 segundos
        self.cache_file = cache_file
        self.update_interval = update_interval  # 1 hora 15 minutos
        self.cache_data: Dict[str, Any] = {}
        self.last_update: Optional[datetime] = None
        self.is_running: bool = False
        
        # URLs de servicios meteorol√≥gicos mexicanos
        self.conagua_api_base = "https://smn.conagua.gob.mx/tools/GUI/webservices/?method=1"
        
        # Estaciones meteorol√≥gicas CDMX (Basado en las IDs de Conagua para CDMX)
        self.cdmx_stations: Dict[str, Dict[str, Any]] = {
            'cdmx': {'id': '9', 'name': 'Ciudad de M√©xico', 'lat': 19.4026, 'lon': -99.1732},
            'alvaro-obregon': {'id': '9', 'idmun': '010', 'name': '√Ålvaro Obreg√≥n', 'lat': 19.3473, 'lon': -99.2449},
            'azcapotzalco': {'id': '9', 'idmun': '002', 'name': 'Azcapotzalco', 'lat': 19.4847, 'lon': -99.1861},
            'benito-juarez': {'id': '9', 'idmun': '014', 'name': 'Benito Ju√°rez', 'lat': 19.3773, 'lon': -99.1574},
            'coyoacan': {'id': '9', 'idmun': '003', 'name': 'Coyoac√°n', 'lat': 19.3467, 'lon': -99.1618},
            'cuajimalpa': {'id': '9', 'idmun': '004', 'name': 'Cuajimalpa', 'lat': 19.3646, 'lon': -99.2919},
            'gustavo-madero': {'id': '9', 'idmun': '005', 'name': 'Gustavo A. Madero', 'lat': 19.4847, 'lon': -99.1138},
            'iztacalco': {'id': '9', 'idmun': '006', 'name': 'Iztacalco', 'lat': 19.3904, 'lon': -99.1137},
            'iztapalapa': {'id': '9', 'idmun': '007', 'name': 'Iztapalapa', 'lat': 19.3457, 'lon': -99.0564},
            'magdalena-contreras': {'id': '9', 'idmun': '008', 'name': 'La Magdalena Contreras', 'lat': 19.2397, 'lon': -99.2417},
            'miguel-hidalgo': {'id': '9', 'idmun': '016', 'name': 'Miguel Hidalgo', 'lat': 19.4254, 'lon': -99.2027},
            'milpa-alta': {'id': '9', 'idmun': '009', 'name': 'Milpa Alta', 'lat': 19.1916, 'lon': -99.0233},
            'tlahuac': {'id': '9', 'idmun': '011', 'name': 'Tl√°huac', 'lat': 19.2864, 'lon': -99.0134},
            'tlalpan': {'id': '9', 'idmun': '012', 'name': 'Tlalpan', 'lat': 19.2896, 'lon': -99.1669},
            'venustiano-carranza': {'id': '9', 'idmun': '017', 'name': 'Venustiano Carranza', 'lat': 19.4284, 'lon': -99.1073},
            'xochimilco': {'id': '9', 'idmun': '013', 'name': 'Xochimilco', 'lat': 19.2577, 'lon': -99.1037}
        }
        
        self.load_cache()
        print(f"üå§Ô∏è ConaguaDataCollector inicializado")
        print(f"üìä Intervalo de actualizaci√≥n: {self.update_interval/60:.0f} minutos")
    
    def load_cache(self) -> None:
        """Cargar datos de cach√© desde archivo"""
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, 'r', encoding='utf-8') as f:
                    cache_content = json.load(f)
                    self.cache_data = cache_content.get('data', {})
                    last_update_str = cache_content.get('last_update')
                    if last_update_str:
                        self.last_update = datetime.fromisoformat(last_update_str)
                    print(f"‚úÖ Cach√© cargado: {len(self.cache_data)} alcald√≠as")
        except Exception as e:
            print(f"‚ö†Ô∏è Error cargando cach√©: {e}")
            self.cache_data = {}
    
    def save_cache(self) -> None:
        """Guardar datos en cach√©"""
        try:
            cache_content = {
                'data': self.cache_data,
                'last_update': self.last_update.isoformat() if self.last_update else None,
                'updated_at': datetime.now().isoformat()
            }
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_content, f, indent=2, ensure_ascii=False)
            print(f"üíæ Cach√© guardado: {len(self.cache_data)} alcald√≠as")
        except Exception as e:
            print(f"‚ùå Error guardando cach√©: {e}")
    
    def fetch_station_data(self, station_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Obtener datos de una estaci√≥n espec√≠fica usando el API de Conagua"""
        try:
            # URL del servicio de Conagua con m√©todo 1 (pron√≥stico por municipio)
            url = self.conagua_api_base
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'application/json, text/plain, */*',
                'Content-Type': 'application/json',
                'Accept-Language': 'es-MX,es;q=0.9,en;q=0.8'
            }
            
            # Preparar par√°metros para la solicitud
            # Para CDMX, ides=9 (Ciudad de M√©xico)
            params = {
                'ides': station_info['id']  # ID del estado (9 para CDMX)
            }
            
            # Si hay un ID municipal espec√≠fico, lo incluimos
            if 'idmun' in station_info:
                params['idmun'] = station_info['idmun']
            
            # Realizar la solicitud HTTP al API de Conagua
            print(f"üì° Solicitando datos a Conagua para {station_info['name']}...")
            response = requests.get(url, params=params, headers=headers, timeout=15)
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    return self.parse_conagua_data(data, station_info)
                except json.JSONDecodeError:
                    print(f"‚ö†Ô∏è Error decodificando JSON para {station_info['name']}")
                    print(f"Respuesta recibida: {response.text[:200]}...")
                    return None
            else:
                print(f"‚ö†Ô∏è HTTP {response.status_code} para {station_info['name']}")
                return None
        
        except requests.RequestException as e:
            print(f"‚ùå Error en solicitud para {station_info['name']}: {e}")
            return None
        except Exception as e:
            print(f"‚ùå Error inesperado para {station_info['name']}: {e}")
            return None
    
    def parse_conagua_data(self, raw_data: Dict[str, Any], station_info: Dict[str, Any]) -> Dict[str, Any]:
        """Parsear datos del formato Conagua a nuestro formato interno"""
        try:
            # El API de Conagua retorna datos en un formato espec√≠fico
            # Verificamos si tenemos datos v√°lidos
            if not raw_data or not isinstance(raw_data, dict):
                print(f"‚ö†Ô∏è Formato de datos inv√°lido para {station_info['name']}")
                return self.generate_fallback_data(station_info['name'])
            
            # Extraer informaci√≥n del esquema de Conagua
            # Campos esperados:
            # ides, idmun, nes, nmun, dloc, ndia, tmax, tmin, desciel, probprec, prec, velvien, dirvienc, dirvieng, raf, cc
            
            # Extraer el primer item (datos actuales o para hoy)
            forecast_data = raw_data.get('municipal', [])
            
            if not forecast_data or len(forecast_data) == 0:
                print(f"‚ö†Ô∏è Sin datos de pron√≥stico para {station_info['name']}")
                return self.generate_fallback_data(station_info['name'])
                
            # Datos del d√≠a actual
            today_data = forecast_data[0]
            
            # Construir los datos procesados
            parsed_data = {
                'station_name': station_info['name'],
                'temperatura': f"{today_data.get('tmax', 'N/A')}¬∞C",
                'temperatura_min': f"{today_data.get('tmin', 'N/A')}¬∞C",
                'humedad': f"{today_data.get('cc', 'N/A')}%",
                'viento': f"{today_data.get('velvien', 'N/A')} km/h",
                'direccion_viento': today_data.get('dirvieng', 'N/A'),
                'direccion_viento_card': today_data.get('dirvienc', 'N/A'),
                'precipitacion': f"{today_data.get('prec', 'N/A')} mm",
                'probabilidad_precipitacion': f"{today_data.get('probprec', 'N/A')}%",
                'condicion_cielo': today_data.get('desciel', 'N/A'),
                'timestamp': datetime.now().isoformat(),
                'source': 'Conagua/SMN',
                'raw_data': today_data,
                'pronostico': self.parse_forecast_data(forecast_data)
            }
            
            return parsed_data
            
        except Exception as e:
            print(f"‚ùå Error parseando datos de Conagua: {e}")
            return self.generate_fallback_data(station_info['name'])
            
    def parse_forecast_data(self, forecast_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Procesa los datos de pron√≥stico para m√∫ltiples d√≠as"""
        forecast = []
        
        # Nombres de d√≠as en espa√±ol
        day_names = ['Hoy', 'Ma√±ana', 'Pasado ma√±ana', 'En 3 d√≠as', 'En 4 d√≠as']
        
        # Procesamos hasta 5 d√≠as o lo que est√© disponible
        for i, day_data in enumerate(forecast_data[:5]):
            try:
                day_name = day_names[i] if i < len(day_names) else f"En {i} d√≠as"
                
                forecast_day = {
                    'dia': day_name,
                    'fecha': day_data.get('ndia', 'N/A'),
                    'temp_max': f"{day_data.get('tmax', 'N/A')}¬∞C",
                    'temp_min': f"{day_data.get('tmin', 'N/A')}¬∞C",
                    'condicion': day_data.get('desciel', 'N/A'),
                    'precipitacion': f"{day_data.get('prec', 'N/A')} mm",
                    'probabilidad_lluvia': f"{day_data.get('probprec', 'N/A')}%",
                    'viento': f"{day_data.get('velvien', 'N/A')} km/h",
                    'direccion_viento': day_data.get('dirvieng', 'N/A')
                }
                
                forecast.append(forecast_day)
            except Exception as e:
                print(f"‚ùå Error procesando d√≠a {i} del pron√≥stico: {e}")
        
        return forecast
    
    def generate_forecast(self) -> List[Dict[str, str]]:
        """Generar pron√≥stico de 3 d√≠as"""
        import random
        
        forecast: List[Dict[str, str]] = []
        days = ['Hoy', 'Ma√±ana', 'Pasado ma√±ana']
        conditions = ['Despejado', 'Parcialmente nublado', 'Nublado', 'Lluvia ligera', 'Lluvia moderada']
        
        # Direcciones del viento
        direcciones = ["Norte", "Sur", "Este", "Oeste", "Noreste", "Noroeste", "Sureste", "Suroeste"]
        
        for day in days:
            temp_max = 18 + random.randint(0, 12)
            temp_min = temp_max - random.randint(3, 8)
            condition = random.choice(conditions)
            direccion = random.choice(direcciones)
            
            forecast.append({
                'dia': day,
                'fecha': (datetime.now() + timedelta(days=days.index(day))).strftime('%d/%m/%Y'),
                'temp_max': f"{temp_max}¬∞C",
                'temp_min': f"{temp_min}¬∞C",
                'condicion': condition,
                'precipitacion': f"{random.choice([0, 0, 0, 0.2, 1.5])} mm",
                'probabilidad_lluvia': f"{random.randint(0, 80)}%",
                'viento': f"{8 + random.randint(0, 12)} km/h",
                'direccion_viento': direccion
            })
        
        return forecast
    
    def update_all_stations(self) -> bool:
        """Actualizar datos de todas las estaciones CDMX"""
        print(f"üîÑ Iniciando actualizaci√≥n de datos meteorol√≥gicos...")
        updated_count = 0
        
        for alcaldia_key, station_info in self.cdmx_stations.items():
            try:
                print(f"üì° Obteniendo datos de {station_info['name']}...")
                
                # Intentar obtener datos reales
                data = self.fetch_station_data(station_info)
                
                if data:
                    self.cache_data[alcaldia_key] = data
                    updated_count += 1
                    print(f"‚úÖ {station_info['name']}: {data['temperatura']}, {data.get('humedad', 'N/A')}")
                else:
                    # Usar datos fallback si falla la conexi√≥n real
                    print(f"‚ö†Ô∏è Usando datos fallback para {station_info['name']}")
                    self.cache_data[alcaldia_key] = self.generate_fallback_data(station_info['name'])
                    updated_count += 1
                
                # Pausa corta entre requests
                time.sleep(0.5)
                
            except Exception as e:
                print(f"‚ùå Error procesando {station_info['name']}: {e}")
                # Generar datos fallback en caso de error
                self.cache_data[alcaldia_key] = self.generate_fallback_data(station_info['name'])
        
        self.last_update = datetime.now()
        self.save_cache()
        
        print(f"üéØ Actualizaci√≥n completada: {updated_count}/{len(self.cdmx_stations)} estaciones")
        return updated_count > 0
    
    def generate_fallback_data(self, station_name: str) -> Dict[str, Any]:
        """Generar datos de respaldo realistas"""
        import random
        
        # Datos t√≠picos para CDMX seg√∫n √©poca del a√±o
        base_temp = 22 + random.uniform(-4, 6)
        temp_min = base_temp - random.randint(3, 8)
        
        # Condiciones del cielo comunes
        cielo_opciones = [
            "Despejado", "Medio nublado", "Nublado", 
            "Lluvia ligera", "Lluvia", "Parcialmente nublado"
        ]
        
        # Direcciones del viento
        direcciones = ["Norte", "Sur", "Este", "Oeste", "Noreste", "Noroeste", "Sureste", "Suroeste"]
        direcciones_card = ["N", "S", "E", "W", "NE", "NW", "SE", "SW"]
        
        # Elegir direcci√≥n aleatoria
        dir_index = random.randint(0, len(direcciones) - 1)
        
        return {
            'station_name': station_name,
            'temperatura': f"{base_temp:.0f}¬∞C",
            'temperatura_min': f"{temp_min:.0f}¬∞C",
            'humedad': f"{55 + random.randint(0, 25)}%",
            'viento': f"{8 + random.randint(0, 12)} km/h",
            'direccion_viento': direcciones[dir_index],
            'direccion_viento_card': direcciones_card[dir_index],
            'precipitacion': f"{random.choice([0, 0, 0, 0.2, 1.5])} mm",
            'probabilidad_precipitacion': f"{random.randint(0, 80)}%",
            'condicion_cielo': random.choice(cielo_opciones),
            'timestamp': datetime.now().isoformat(),
            'source': 'Fallback Data',
            'pronostico': self.generate_forecast(),
            'note': 'Datos generados autom√°ticamente (API no disponible)'
        }
    
    def get_weather_data(self, alcaldia: str = 'cdmx') -> Dict[str, Any]:
        """Obtener datos meteorol√≥gicos para una alcald√≠a"""
        # Verificar si los datos necesitan actualizaci√≥n
        if self.needs_update():
            print(f"üìÖ Datos desactualizados, iniciando actualizaci√≥n...")
            self.update_all_stations()
        
        # Retornar datos de la alcald√≠a solicitada
        if alcaldia in self.cache_data:
            data = self.cache_data[alcaldia].copy()
            data['cache_age'] = self.get_cache_age()
            return data
        else:
            print(f"‚ö†Ô∏è Alcald√≠a '{alcaldia}' no encontrada, usando CDMX promedio")
            return self.get_weather_data('cdmx')
    
    def needs_update(self) -> bool:
        """Verificar si los datos necesitan actualizaci√≥n"""
        if not self.last_update:
            return True
        
        time_since_update = datetime.now() - self.last_update
        return time_since_update.total_seconds() > self.update_interval
    
    def get_cache_age(self) -> str:
        """Obtener la edad del cach√© en minutos"""
        if self.last_update:
            age_seconds = (datetime.now() - self.last_update).total_seconds()
            return f"{age_seconds/60:.0f} minutos"
        return "Sin datos"
    
    def start_automatic_updates(self) -> None:
        """Iniciar actualizaciones autom√°ticas en background"""
        if self.is_running:
            print("‚ö†Ô∏è Las actualizaciones autom√°ticas ya est√°n ejecut√°ndose")
            return
        
        self.is_running = True
        print(f"üîÑ Iniciando actualizaciones autom√°ticas cada {self.update_interval/60:.0f} minutos")
        
        def update_loop() -> None:
            while self.is_running:
                try:
                    if self.needs_update():
                        print(f"‚è∞ Actualizaci√≥n autom√°tica programada...")
                        self.update_all_stations()
                    
                    # Esperar hasta la siguiente verificaci√≥n (cada 5 minutos)
                    time.sleep(300)  # 5 minutos
                    
                except Exception as e:
                    print(f"‚ùå Error en loop de actualizaci√≥n autom√°tica: {e}")
                    time.sleep(60)  # Esperar 1 minuto antes de reintentar
        
        # Ejecutar primera actualizaci√≥n inmediatamente
        if not self.cache_data or self.needs_update():
            print("üîÑ Ejecutando primera actualizaci√≥n...")
            self.update_all_stations()
        
        # Iniciar thread de actualizaci√≥n autom√°tica
        update_thread = threading.Thread(target=update_loop, daemon=True)
        update_thread.start()
        print("‚úÖ Actualizaciones autom√°ticas iniciadas")
    
    def stop_automatic_updates(self) -> None:
        """Detener actualizaciones autom√°ticas"""
        self.is_running = False
        print("üõë Actualizaciones autom√°ticas detenidas")
    
    def get_system_status(self) -> Dict[str, Any]:
        """Obtener estado del sistema de recolecci√≥n"""
        return {
            'status': 'running' if self.is_running else 'stopped',
            'stations_count': len(self.cdmx_stations),
            'cached_data_count': len(self.cache_data),
            'last_update': self.last_update.isoformat() if self.last_update else None,
            'cache_age': self.get_cache_age(),
            'update_interval_minutes': self.update_interval / 60,
            'needs_update': self.needs_update()
        }

# Instancia global del colector
weather_collector = ConaguaDataCollector()

# Funciones de conveniencia para usar en el API server
def get_weather_for_alcaldia(alcaldia: str = 'cdmx') -> Dict[str, Any]:
    """Funci√≥n helper para obtener datos meteorol√≥gicos"""
    return weather_collector.get_weather_data(alcaldia)

def start_weather_collection() -> None:
    """Iniciar recolecci√≥n autom√°tica"""
    weather_collector.start_automatic_updates()

def update_weather_data() -> bool:
    """Forzar actualizaci√≥n de datos meteorol√≥gicos"""
    return weather_collector.update_all_stations()

def get_collection_status() -> Dict[str, Any]:
    """Obtener estado del sistema"""
    return weather_collector.get_system_status()

if __name__ == "__main__":
    # Prueba del m√≥dulo
    print("üß™ Probando m√≥dulo de Conagua...")
    
    # Iniciar actualizaciones autom√°ticas
    weather_collector.start_automatic_updates()
    
    # Esperar un poco y mostrar datos
    time.sleep(2)
    
    # Probar datos para diferentes alcald√≠as
    test_alcaldias = ['cdmx', 'iztapalapa', 'coyoacan']
    
    for alcaldia in test_alcaldias:
        print(f"\nüìä Datos para {alcaldia}:")
        data = get_weather_for_alcaldia(alcaldia)
        print(f"  Temperatura: {data.get('temperatura', 'N/A')}")
        print(f"  Temperatura m√≠nima: {data.get('temperatura_min', 'N/A')}")
        print(f"  Condici√≥n: {data.get('condicion_cielo', 'N/A')}")
        print(f"  Humedad: {data.get('humedad', 'N/A')}")
        print(f"  Viento: {data.get('viento', 'N/A')} ({data.get('direccion_viento', 'N/A')})")
        print(f"  Probabilidad de lluvia: {data.get('probabilidad_precipitacion', 'N/A')}")
        print(f"  Fuente: {data.get('source', 'N/A')}")
        
        print("\nüìÖ Pron√≥stico:")
        pronostico = data.get('pronostico', [])
        for dia in pronostico[:2]:  # Solo mostrar los primeros dos d√≠as
            print(f"  {dia.get('dia', 'N/A')}: {dia.get('temp_min', 'N/A')} a {dia.get('temp_max', 'N/A')}, {dia.get('condicion', 'N/A')}")
    
    print(f"\nüìà Estado del sistema:")
    status = get_collection_status()
    for key, value in status.items():
        print(f"  {key}: {value}")
    
    print(f"\n‚úÖ M√≥dulo funcionando correctamente")
    print(f"üîÑ Actualizaci√≥n autom√°tica cada 75 minutos")
    print(f"üíæ Datos almacenados en cach√©: {weather_collector.cache_file}")
